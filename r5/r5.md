Keoni Burns  
CSCi 551

# Report 5

## Q1

$$\boxed {\begin{split} {3x-0.1y-0.2z=7.85, \  0.1x7y-0.3z = -19.3, \ 0.3x - 0.2y + 10z = 71.4} \end{split}}$$

- the system above is what we are asked to solve for using subsstitution and gaussian elimination

<img src = ./ss/verification1.jpg alt="drawing" width = "600" style="centered"/>

- this the verification for the solution using symbolab

### Simple Substitution

<img src="./ss/sub1.jpg" alt="handwork" height = "600"/>
<img src="./ss/sub2.jpg" alt="handwork" height = "600"/>

- above is the handwritten method for substitution
- as you can see in the there is a minor discrepency with the values however this is caused by rounding errors from the calculator being used as well as the numher of sigfigs being inconsistent towards the end of the problem

### Gaussian Elimination

### gewpp program vs gsit program

<img src= "./ss/gewppvgsit.jpg" width = "600"/>

- as you can see from the above image both programs are essentially the same in terms of speed and accuracy
  - that being said i believe that in terms of readability gsit is much easier to understand as there aren't as many loops and indeces to keep track of

## Q2

### implementation

```cpp
using namespace std;
int main(int argc, char *argv[]) {
    struct timespec start, stop;
    double fstart, fstop;
    double first_sum = 0.0, sec_sum = 0.0;
    unsigned int length = 0;
    double constant = 1.0;
    unsigned int i = 0;
    int threads = 4;  // for default

    if (argc < 2) {
        cerr << "usage: ./ex2 <number of iterations, n> <number of threads>" << endl;
        exit(-1);
    } else {
        length = atoi(argv[1]);
    }
    if (argc == 3) {
        threads = atoi(argv[2]);
    }

    clock_gettime(CLOCK_MONOTONIC, &start);
    fstart = (double)start.tv_sec + ((double)start.tv_nsec / 1000000000.0);

#pragma omp parallel for num_threads(threads) reduction(+ : first_sum) reduction(+ : sec_sum) private(i) shared(length)
    for (i = 0; i < length; i++) {
        if (i % 2 == 0) {
            first_sum += constant / ((2.0 * (double)i) + 1.0);
        } else {
            first_sum += -constant / ((2.0 * (double)i) + 1.0);
        }
        sec_sum += 2.0 / (((4.0 * (double)i) + 1.0) * (4.0 * (double)i + 3.0));
    }

    clock_gettime(CLOCK_MONOTONIC, &stop);
    fstop = (double)stop.tv_sec + ((double)stop.tv_nsec / 1000000000.0);

    double Merr = 1000000000.0 * ((M_PI - (4.0 * first_sum)));
    double Eerr = 1000000000.0 * ((M_PI - (4.0 * sec_sum)));
    cout << setprecision(16);
    cout << "Madvha-Leibniz pi: \n" << (4 * first_sum) << endl;
    cout << "Euler pi: \n" << (4 * sec_sum) << endl;
    cout << "% error for the two in their respective order are:\n" << Merr << "\n" << Eerr << endl;
    cout << "\n\n"
         << "monotonic time: " << (fstop - fstart) << endl;
    return 0;
}
```

above is the code for the program

The logic is as follows:

- check command line args for correct usage
- iterate from 0 to n

  - if divisible by 2 then the value of the series should be positive
  - this is the madvha-leibniz series which can be described by:
    $$
    \boxed{
        \Sigma ({2 \over n+1}),  where \ n \ is \ even
    }
    $$
    $$
    \boxed{
        \Sigma (-{2 \over n+1}),  where \ n \ is \ odd
    }
    $$
  - the second sum is the euler method which can be described by the series

  $$
  \boxed{
    \Sigma ({2 \over((4n+1)(4n+3))}), from \ 0 \ to \ n
  }
  $$
